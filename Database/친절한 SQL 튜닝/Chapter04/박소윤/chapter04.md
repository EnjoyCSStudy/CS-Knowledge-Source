## 4.1 [[NL 조인]]

### 4.1.1 기본 메커니즘

NL 조인은 [[인덱스]]를 이용한 조인이다.

```java
for (int i = 0; i < 100; i++) {    -- outer loop
	for (int j = 0; j < 100; j++) {    -- inner loop
		...
	}
}
```

NL(Nested Loop) 조인은 위의 중첩 루프문과 같은 수행 구조를 가진다.

### 4.1.2 NL 조인 실행계획 제어

`use_nl` 힌트를 사용하여 NL 방식으로 조인하라고 지시할 수 있다.
`ordered`, `leading`과 같은 힌트를 사용하여 조인 순서를 제어할 수 있다.
- 순서에 관한 힌트를 기술하지 않으면 옵티마이저가 스스로 정한다.

### 4.1.3 NL 조인 수행 과정 분석

수행의 각 단계를 모두 완료하고 넘어가는 것이 아니라 한 레코드 씩 순차적으로 진행함을 확인할 수 있다.
- 정말 for-loop의 동작 방식과 유사하다!

### 4.1.4 NL 조인 튜닝 포인트

Outer 테이블과 Inner 테이블의 인덱스를 튜닝함으로써 비효율을 개선할 수 있다.
- Outer 테이블 -> 전체 결과 레코드 개수, 테이블 랜덤 액세스 횟수를 최적화 
- Inner 테이블 ->  조인 액세스 횟수, 테이블 랜덤 액세스 횟수를 최적화
- [[인덱스 튜닝 기법]]

### 4.1.5 NL 조인 특징 요약

1. 랜덤 액세스 위주의 조인 방식이다.
	1. 인덱스 구성이 아무리 완벽해도 대량 데이터 조인에 불리하다.
2. 한 레코드씩 순차적으로 진행한다.
	1. 부분범위 처리를 활용하면 대량의 데이터라도 매우 빠른 응답속도를 낼 수 있다.
	2. 먼저 액세스되는 테이블의 처리 범위에 의해 전체 일량이 결정된다.
3. 인덱스 구성 전략이 특히 중요하다.

결론적으로 소량의 데이터를 주로 처리하거나, 부분범위 처리가 가능한 OLTP 시스템에 적합한 조인 방식이다.

### 4.1.6 NL 조인 튜닝 실습


### 4.1.7 NL 조인 확장 메커니즘

#### 테이블 Prefetch

인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면, 이어서 곧 읽게 될 블록까지 미리 읽어서 [[버퍼캐시]]에 적재한다.

`nlj_prefetch`, `no_nlj_prefetch` 힌트를 이용해 실행계획을 설정할 수 있다.

#### 배치 I/O

디스크 I/O Call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리한다.
- 읽는 블록마다 건건이 I/O Call을 발생시킬 필요가 없다.

`nlj_batching`, `no_nlj_batching` 힌트를 이용해 실행계획을 설정할 수 있다.

Inner 테이블 블록을 모두 버퍼캐시에서 읽는다면 성능에 큰 차이는 없다.
그러나, 일부를 디스크에서 읽게 되면 성능 차이가 날 수 있다.
- 왜지?

또한 결과집합의 정렬 순서가 달라질 수도 있기 때문에 주의가 필요하다.
- `no_nlj_bathcing` 힌트를 추가하거나 ORDER BY 절을 명시해주어야 한다.


## 4.2 [[소트 머지 조인]]

조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이여서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.


### 4.2.1 SGA vs. PGA

#### SGA

공유 메모리 영역인 ==SGA==에 캐시된 데이터는 여러 프로세스가 공유할 수 있다.
- 그러나 동시에 액세스할 수는 없다.
- 프로세스 간 액세스 직렬화를 위한 Lcok 매커니즘으로 [[래치]](Latch)가 존재한다.

DB [[버퍼캐시]]는 SGA의 가장 핵심적인 구성요소로, 여기서 블록을 읽기 위해 버퍼 Lock을 얻어야 한다.

#### PGA

오라클 서버 프로세스에 할당된 메모리 영역은 ==PGA==라고 부르며, 프로세스에 종속적인 고유 데이터를 저장한다.

독립된 메모리 공간이므로 래치 매커니즘이 불필요하여 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.

### 4.2.2 기본 매커니즘

#### 소트 단계

양쪽 집합을 조인 컬럼 기준으로 정렬한다.

#### 머지 단계

정렬한 양쪽 집합을 서로 머지한다.

#### SQL 수행 과정

소트 머지 조인은 `use_merge` 힌트로 유도할 수 있다.

1. 양쪽 테이블을 조인 컬럼을 기준으로 정렬한다.
	1. 정렬한 결과 집합은 PGA 영역에 할당된 Sort Area에 저장한다.
2. Outer 테이블의 레코드를 스캔하면서 Inner 테이블의 레코드와 조인한다.
	1. 머지 단계는 NL 조인과 다르지 않다.

Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 조인 컬럼에 인덱스가 없어도 사용할 수 있다.

### 4.2.3 소트 머지 조인이 빠른 이유

NL 조인은 인덱스를 이용한 조인 방식으로, 조인 과정에서 액세스 하는 모든 블록을 랜덤 액세스 방식으로 읽는다.
- 버퍼캐시(SGA)에서 데이터를 읽기 떄문에 래치 획득 과정이 필요하다.
- 건건이 버퍼캐시를 공유해야 한다.

소트 머지 조인은 조인 대상 집합을 일괄적으로 읽어 PGA에 저장한 후 조인한다.
- PGA에서 데이터를 읽기 때문에 래치 획득 과정이 필요없다.
- 양쪽 집합에 대한 소트 연산을 추가로 하기 떄문에 느리지 않을까?
	- 그렇기 때문에 대량 데이터 조인 시 유리하다.

그러나 소트 머지 조인도 ==양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유==한다.
- 이때 인덱스를 이용하기도 하기 때문에 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 피할 수 없다.

### 4.2.4 소트 머지 조인의 주용도

해시 조인의 등장으로 조금 뒷전으로 밀려났다.
그래도 소트 머지 조인을 사용할 수 있는 상황이 있다.

1. 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
	1. 해시 조인은 조인 조건식이 등치(=)일 때만 사용할 수 있다.
2. 조인 조건식이 아예 없는 조인 (카테시안 곱)

### 4.2.5 소트 머지 조인 제어하기

 NL 조인과 마찬가지로 `ordered`, `leading` 힌트로 순서를 제어할 수 있다.

### 4.2.6 소트 머지 조인 특징 요약

1. 소트 머지 조인은 PGA 영역에 저장한 데이터를 사용하기 떄문에 빠르다.
	1. 소트 부하만 감수한다면, NL 조인보다 빠르다.
2. 소트 머지 조인은 조인 컬럼에 대한 인덱스의 유무에 크게 영향을 받지 않는다.
3. 스캔 위주의 액세스 방식을 사용한다.
	1. 양쪽 테이블로부터 조인 대상 레코드를 찾을 때에는 인덱스를 이용할 수도 있다.
