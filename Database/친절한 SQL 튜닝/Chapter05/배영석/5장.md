## 소트연산
- PGA에 할당한 Sort Area에서 이루어짐

#### 메모리 소트
- 전체 데이터의 정렬 작업을 메모리 내에서 완료
#### 디스크 소트
- 할당받은 Sort Area 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우

### 소트 과정
1. 대상집합을 SGA 버퍼캐시를 통해 읽어들이고 정렬 시도
2. 양이 많으면 Temp 테이블스페이스에 임시 세그먼트를 만들어 저장
    - 이를 Sort Run이라고 부름
3. 다시 PGA로 읽어들이면서 머지

> 소트 연산은 메모리 집약적일뿐만 아니라 CPU 집약적
> 부분처리도 안됨

## 소트를 발생시키는 연산

#### 1. sort aggregate
- 전체 로우를 대상으로 집계
- 정렬하진 않지만 sort area를 사용
#### 2. sort order by
- 데이터 정렬
#### 3. sort group by
- 소팅 알고리즘을 사용해 그룹별 집계를 수행할 때
- 부서를 메모지로 나누는 아이디어

> hash group by
- group by 절 뒤에 order by 절을 명시하지 않으면 hash group by
- 메모지를 찾기 위해 해싱 알고리즘 사용
- 읽는 레코드마다 Group by 컬럼의 해시 값으로 해시 버킷을 찾아 그룹별로 집계 항목을 갱신

> 그룹핑의 결과는 정렬 순서를 보장하지 않는다.

	소팅 알고리즘을 사용해 값을 집계한다는 뜻일 뿐 결과의 정렬을 의미하지는 않는다.
	논리적 순서가 아닌 물리적 순서로 읽을 수 있기 때문
	정렬된 그룹핑 결과를 얻고자 한다면, 실행계획에 Sort Group By라고 표시되더라도 반드시 Order by를 명시해야한다.

#### 4. sort unique
- 서브쿼리 unnesting하는 과정에서 메인 쿼리와 조인하기 전에 중복 레코드부터 제거
- PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting 된 서브쿼리의 유일성이 보장된다면 sort unique 오퍼레이션은 생략
- union, minus, intersect 같은 집합 연산자에서도 사용됨
- distinct에도 (Hash Unique)
#### 5. sort join
- 소트 머지 조인할때
#### 6. window sort
- 윈도우 함수를 수행할 때

## 소트가 발생하지 않도록 SQL 작성

#### Union
- 중복을 제거하기 위해 sort 작업 수행
- union all
    - 소트 작업 수행 x
    - 단 데이터가 중복되는 문제가 발생할 수 있음
    - 중복을 피하려면 중복될 수 있는 컬럼을 배제해야함
- 상호배타적일 때는 Union 사용 가능

#### exists
- distinct 연산자
	- 데이터를 모두 읽어서 중복 제거
	- 부분범위 처리 불가
- exists 서브쿼리
	- 데이터 존재 여부만 확인하면 되기 때문에 조건절을 만족하는 데이터를 모두 읽지 않는다.
    
#### 조인 전략에 따른 소트 연산 생략
- 인덱스를 활용한 NL 조인
- 정렬 기준이 조인 키 컬럼이면 소트 머지 조인도 Sort Order By 연산을 생략할 수 있다.